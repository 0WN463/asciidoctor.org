//== Include directive

// Didnt like it before because it was too reference like; Have I now gone too tutorial instead?

The include directive allows you to insert content from a file into a parent file, effectively merging the content.
Use includes to:

// The links were for my info - so I removed them, but woulds they be useful?

* partition a large document into several smaller files 
// <<include-partition>>, <<include-filemanagement>>
* re-use fragments and boiler plate many times in the same document 
// <<include-basics>> <<include-multiple>>
* easily restructure documents 
// <<include-partition>>
* create document familes by combining `include` with `#ifdef`
// <<include-nonasciidoc>>
* populate tables with data from other programs 
// <<include-nonasciidoc>>
* insert snippets of source code files so that your documentation is always up-to-date with the program
//<<include-byparts>>

CAUTION: The include directive is _disabled_ when Asciidoctor is in secure mode. 
// , which is the default safe mode when using Asciidoctor via the API.
In secure mode, include directives become _links_ in the output document.
To learn more about secure mode, refer to the section <<Running Asciidoctor Securely>>.

[[include-basics]]
=== Basics
An include has these parts:

`include::__filename__[__leveloffset=offset,lines=linerange,tags=tagslist__]`

leveloffset, lines, and tags are optional, so the simplest case looks like:

[source]
----

= My document

\include::content.adoc[]

----

TIP: Note the blank lines before and after the include directive. 
This is recommended to avoid unexpected results (e.g., a section title getting appended to the end of a previous paragraph).

If you mis-type the filename so that Asciidoctor cannot find it, you will still be able to convert the document, but you will get a warning during conversion (`include file not found: content.adoc`), and this message will be inserted into the output:

// confirmed in html and docbook

[source,text]
----
Unresolved directive in master.adoc - include::content.adoc[]
----

Edit the file path and try again.

[[include-partition]]
=== Partitioning large documents: leveloffset

When your document gets large, you can split it up into subsections for easier editing:

[source]
----
= My book

\include::chapter01.adoc[]

\include::chapter02.adoc[]

\include::chapter03.adoc[]
----

leveloffset helps here by pushing all headings in the included document down by the specified number of levels.
In the example above, while you are working you might want to publish each chapter separately, so that each chapter has to be a complete document with a header.
When you are finished, you can easily assemble your book so that the chapter document titles become level 1 headings using:
[source]
----
= My Book

\include::chapter01.adoc[+1]

\include::chapter02.adoc[+1]

\include::chapter03.adoc[+1]
----

Because the leveloffset is _relative_ (it begins with + or -) this works even if the included document has its own includes and leveloffsets.

If you have lots of chapters to include and want them all to have the same offset, you can save some typing by setting leveloffset at the document level instead:

[source]
----
= My book

:leveloffset: +1

\include::chapter01.adoc[]

\include::chapter02.adoc[]

\include::chapter03.adoc[]

:leveloffset: -1

----

Note the final line returning the leveloffset to 0.

You could use absolute levels instead:

[source]
----
:leveloffset: 1
...
:leveloffset: 0
----

but relative levels are preferred because absolute levels become awkward when you have multiple levels of include.

[[include-filemanagement]]
=== File management

// Relegate base directory to a footnote because I suspect it is an edge case.
// Why isnt it working in the rendered document?

The file path can be relative or absolute.
If it is relative, it is assumed to be relative to the _including_ file.footnote:[Except for files included in the master (top-level) document. These are resolved relative to the base directory, which defaults to the directory of the master document, but can be overridden from the command line with `--base-dir`.]
This makes it easy to work out what to type when you are editing the including file:

[source]
----
\include::../_includes/fragment1.adoc[]
----

However, if you keep your Asciidoc files in nested folders at different levels, relative file paths quickly become awkward and inflexible.
You can try to keep all your files at the same nesting level, but a more common pattern is to define the path (or several paths) in a variable at the top of the document:

[source]
-----
:includedir: _includes
:sourcedir: ../src/main/java

\include::{includedir}/fragment1.adoc[]

[source,java]
----
\include::{sourcedir}/org/asciidoctor/Asciidoctor.java[]
----

-----

[[include-nonasciidoc]]
=== Asciidoc vs non-Asciidoc files

The include directive performs a simple file merge, so it works with any text file.
But if the file is recognized as an Asciidoc file (ie it has an extension of `.asciidoc`, `.adoc`, `.ad`, `.asc`, or `.txt`), it will action these Asciidoc commands:

* header attributes
* ifdef
* include

This allows includes to be nested, and provides lot of flexibility in constructing radically different documents with a single master document and a few command line attributes.

// does this need an example?

On the other hand, including non-Asciidoc files is normally to merge output from other programs, or include data for graphics:

[source]
----
.2016 Company Results
|====

\include::../export/2016/results.csv[]

|====
----

The include directive does not do any processing, and the file is inserted as-is.

// Am I warning people off doing something they would never have thought of otherwise?

CAUTION: You *can* put Asciidoc content in a non-Asciidoc file. 
Its content will still be processed as Asciidoc, but any include statements will be ignored, and therefore cause errors later in processing.
It is likely to cause confusion, so best avoided.
